#pragma once

// External includes
#include <vector>

// Internal includes
#include "util\Vector3D.h"
#include "Texture.h"

namespace render {

	/**
	 * This class represents one single Vertex
	 * It holds a position, a color and The texture cordinates
	 * @author sascha blank
	 */

	class Vertex
	{
	public:
		util::VectorF position;
		util::VectorF color;
		util::VectorF textureCords;
		util::VectorF normal;
		int id;

		Vertex()
		{
			position.set(0.0f, 0.0f, 0.0f);
			color.set(1.0f, 1.0f, 1.0f);
			textureCords.set(0.0f, 0.0f, 0.0f);
			normal.set( 0.0f, 0.0f, 0.0f );
		}

		Vertex(const Vertex& t_other)
		{
			if (this != &t_other)
			{
				*this = t_other;
			}
		}

		Vertex& operator=(const Vertex& t_other)
		{
			if (this != &t_other)
			{
				position = t_other.position;
				color = t_other.color;
				textureCords = t_other.textureCords;
				id = t_other.id;
			}
			return *this;
		}
	};


	/**
	 * This clas represents a face which holds 3 Vertecis
	 * @author sascha blank
	 */
	class Face
	{
	public:
		int vertcies[3];
		int materialID;
		util::VectorF normal;
		bool smooth;
		int ID;

		Face()
		{
			// empty body
		}

		Face(const Face& t_other)
		{
			if (this != &t_other)
			{
				*this = t_other;
			}
		}

		Face& operator=(const Face& t_other)
		{
			if (this != &t_other)
			{
				vertcies[0] = t_other.vertcies[0];
				vertcies[1] = t_other.vertcies[1];
				vertcies[2] = t_other.vertcies[2];
			}
		}
	};


	class Material
	{
	public:
		Material()
		{
			specularTexture = nullptr;
			diffuseTexture = nullptr;
		}

		~Material(){}
		int ID;
		Texture* specularTexture;
		GLuint specularTextureID;
		Texture* diffuseTexture;
		GLuint diffuseTextureID;
		util::VectorF specularColor;
		util::VectorF diffuseColor;

		
	};

	/**
	 * This class represents the Mesh to render with all the faces needed.
	 * Just create a new Mesh object and add faces to it.
	 * @author sascha blank
	 */
	class Mesh
	{
	public:

		/**
		 * Default constructor
		 * @author Sascha Blank
		 */
		Mesh(void);

		/**
		 * Virtual destructor
		 * @author sascha blank
		 */
		virtual ~Mesh();

		/**
		 * Add a new Face to the mesh.
		 * @author sascha Blank
		 * @param p_face, pointer to the face which is added to the mesh
		 */
		void addFace(Face* p_face);

		/**
		 * This function adds a Vertex to the vertex list
		 * @author sascha blank
		 * @param Vertrex, vertex pointer to add
		 */
		void addVertex( Vertex* p_vertex );

		/**
		 * Function to return all faces of the mesh
		 * @author sascha Blank
		 * @return const std::list<Face*>&, list with all faces of the mesh
		 */
		const std::vector<Face*>& getFaces(void) const;



		/**
		 * Set the shaderprogramname to use to rendering the mesh
		 * @author sascha blank
		 * @param const std::string&, the shaderprogramm to use
		 */
		void setShaderProgramName( const std::string& p_shaderProgramm );

		/**
		 * Function to return the shaderprogramm name used in this mesh
		 * @author sascha blank
		 * @return const std::string& the shader program name
		 */
		const std::string& getShaderProgramNameName( void );
		
		/**
		 * Function to generate a new vertextbuffer and add it to OpenGL.
		 * Call this function after the mesh generation is done
		 * @author sascha blank
		 */
		void generateBuffer( void );
		

		/**
		 * Returns the VAO id which is generated by OpenGL
		 * @author sascha blank
		 * @return GLuint, the VAO ID
		 */
		GLuint getVAO_ID( void );

		/**
		 * Returns the amount of vertecis to render.
		 * @author sascha blank
		 * @return size_t, the amount of vertecis to render
		 */
		size_t getVertexCount( void );

		/**
		 * Function to add a Material to the mesh
		 * @author sascha blank
		 * @param Material* the material to add
		 */
		void setMaterial( Material* p_material );

		/**
		 * Returns the current used material
		 * @author sascha blank
		 * @return Material*, the current used material
		 */
		Material* getMaterial( void );

		GLuint generateInstaciatetBuffer( int p_amount, glm::mat4* modelMatrices );

	private:

		Material* m_material;

		// vertecis to render
		std::vector<Vertex*>m_vertecis;

		// vector with the indicis
		std::vector<Face*>m_faces;

		// Shader to use
		std::string m_shaderProgramName;


		// Vertex buffer
		float* m_vertexBuffer;

		// Indecis buffer
		int* m_indices;

		// indecis buffer id 
		GLuint m_indicesID;

		// vertex buffer id
		GLuint m_vertexBufferID;

		// id of the VAO
		GLuint m_VAO;
	};
}